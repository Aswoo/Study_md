면접 질문 

## 안드로이드 4대 컴포넌트

안드로이드를 구성하는 구성요소로 `Activity` , `Service` , `Content Provider` , `Broadcast Recevier` 가 있습니다.

`Activity` 는 *UI* 를 가지는 화면을 나타냅니다. 화면마다 `Activity` 로 구현되며 *xml* 파일을 통해 뷰와 레이아웃을 구현하고 `setContentView()` 를 통해 파일을 메모리로 `Infalte` 시켜 화면에 출력합니다.

`Service` 는 화면 없이 백그라운드에서 실행되는 구성요소로써 오랫동안 작업을 하거나 원격 작업을 수행할 경우 사용됩니다. 보통 음악을 재생하거나 화면과 별개로 타이머를 재거나 네트워크 통신을 할 경우 사용됩니다.

`Content Provider` 는 공유된 앱 데이터를 관리합니다. 어플리케이션간 데이터를 접근하기 위해 사용됩니다. 파일 시스템이나 SQLite 데이터베이스, 기타 저장소 위치에서 앱이 접근 가능한 저장소의 데이터를 읽거나 쓸 수 있습니다. 예를 들어 연락처 앱의 연락처 정보를 가져올 수 있고 갤러리 앱의 사진 파일을 가져오거나 외부 저장소에 파일을 저장할 수 있습니다.

`Broadcast Receiver` 는 시스템이 보내는 브로드캐스트 알림을 응답하는 구성요소입니다. 예를 들어 화면이 꺼지거나 배터리가 부족하거나 사진을 캡쳐하는 등의 이벤트에 대해 시스템이 브로드캐스트를 날리면 앱에서 `Receiver` 를 통해 원하는 브로드캐스트를 수신하여 이에 맞는 처리를 가능케 합니다. 앱 내에서도 `LocalBroadcastManager` 를 통해 브로드캐스트에 데이터를 담은 `Intent` 를 보내어 다른 컴포넌트에서 수신할 수도 있습니다.

1. HashMap vs HashTable vs ConcurrentHashMap

- Hashtable은 put, get과 같은 주요 메소드에 synchronized 키워드가 선언 되어 있습니다. 또한 key, value에 null을 허용하지 않습니다. 아래의 코드는 기본적인 사용법입니다.
- HashMap은 주요 메소드에 synchronized 키워드가 **없습니다**. 또한 Hashtable과 다르게 key, value에 null을 입력할 수 있습니다.
- HashMap을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap입니다. 하지만 HashMap과는 다르게 key, value에 null을 허용하지 않습니다. 또한 putIfAbsent라는 메소드를 가지고 있습니다. 해당 부분은 아래 코드의 주석을 참고하시기 바랍니다.

2. 접근 제어자에 대해 설명하시오

   -  public (생략가능) : 전체 공개입니다. 아무것도 안쓰면 기본적으로 public 입니다.

   - private : 현재 파일 내부에서만 사용할 수 있습니다.
   -  protected :상속받은 클래스에서 사용할 수 있습니다
   - internal : 자바에서는 같은 패키지에서만 접근 가능 kotlin 에서는 같은 모듈안에서만 사용 가능하다.

3. 제네릭이란

   - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법.
   - 제네릭을 사용하는 이유는 **타입성 안정성과 확장성**
   - 기능을 구현할때 제네릭을 사용하면 다양한 자료형에 적용이 가능하여 확장성을 보장할 수 있다. 이러한 특징은 `Object`를 통해서도 보장이 가능하지만 `Object`는 타입에 대한 검사가 이뤄지지 않기 때문에 컴파일 타임에 문제를 인지할 수 없다
   - 반면 제네릭은 사용하고자하는 자료형을 명시적으로 표시함으로써 잘못된 자료형을 컴파일타임에 찾을 수 있다. 비록 제네릭은 생략될 수 있기 때문에 명시적인 자료형 선언 없이도 사용이 가능하여 타입 안전성이 무너질 수 있으나 컴파일이 경고를 통해 타입 안전성이 깨진다는 메세지를 보냄으로써 문제 유발 가능성을 알 수 있다.

4. code , data , stack , heap

   - code : 코드 자체를 구성하는 메모리영역 bin, hex 파일임
   - data : 전역변수(global),정적변수(static),배열,구조체 등이 저장된다.
   - stack : 프로그램이 자동으로 사용하는 임시 메모리 영역 , 지역변수(local) , 매개변수(parameter) 리턴 값등 잠시 사용되었다가 사라지는 데이터를 저장한다.
   - heap :  필요에 의해 동적으로 메모리를 할당하고자 할 때 위치하는 메모리 영역으로 동적 데이터 영역이라고 한다., 메모리 주소 값에 의해서만 참조되고 사용되는 영역이다.

5. Locality의 관점에서 QuickSort가 MergeSort 보다 빠른 이유

   - Quick sort와 Merge sort는 nlogn의 시간복잡도를 가지는 대표적인 정렬 방법이다.
   - Locality : *지역성(Locality)은 CPU가 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복적으로 엑세스하는 경향을 말한다.*

6. 리플렉션이란?

   - 객체를 통해 클래스의 정보를 분석하는 프로그램 기법을 말한다.
   - 해당 객체의 클래스 정보를 컴파일 시점에서 알 수 없는 경우라도, 런타임 시점에서 객체를 직접 분석하여 내부 클래스 정보를 알아내어 활용 할 수 있다. java.lang.reflection을 import하여 사용 가능하다.

7. 자바의 실행과정

   *Java* 는 *Java* 코드를 컴파일러를 통해 바이트코드로 변환시킨 뒤 *JVM* 위에 실행시키는 구조이다.

   *JVM* 구조에는 *Class Loader*, *Execution Engine*, *Garbage Collector*, *Runtime Data Areas* 가 있다.

   - Class Loader : 컴파일러에 의해 바이트 코드로 변환된 코드를 Runtime Data Areas 에 클래스 단위로 로드시키고 Link를 통해 적절히 배치시키는 작업을 한다. 클래스 로드로 인해 동적으로 클래스를 로드할 수 있다. 

   - Execution Engine : Runtime Data Areas 에 배치된 바이트 코드를 실행시키는 역할을 한다. 메모리에 올라온 코드를 **명령어 단위**로 실행한다.

   - Runtime Data Areas : 운영체제로부터 할당받은 메모리를 관리하는 영역이다. JVM 에서 관리하는 메모리 영역은 Method Area,Runtime Constant Pool, Heap Area,Stack Area,PC Register ,Native Method Stack

   - ##### Method (Static or Class) Area

     호출한 클래스와 인터페이스에 대한 *Runtime Constant Pool*, 메소드와 필드, Static 변수, 메소드 바이트 코드 등을 저장한다.

   - Heap Area : 런타임에서 동적으로 할당하는 객체를 지정하는 곳이다. new 연산자를 통해 생성되는 객체와 배열을 저장하며 GC의 주 대상이 된다.

     - Young Generation : 객체가 생성되자마자 저장되는 공간, 시간이 지날수록 우선순위가 낮아지며 OLD 영역으로 내려가게 된다. Minor GC로 객체를 사라지게함

     - Old Generation : 오래된 객체가저장되는 곳 이곳에서 객체가 사라지면 Major GC 가 발생한다.

       Permanent Genration : *Class Loader* 에 의해 로드되는 클래스나 메소드에 대한 *Meta* 정보가 저장되는 영역이다. `Reflection`을 이용하여 동적으로 클래스를 로드하는 경우 자주 사용된다.

     - ##### Stack Area

       *Stack* 구조의 저장공간이다. 함수 호출시 발생하는 지역변수, 매개변수, 연산 데이터 등을 저장하는 공간이다. 함수를 호출하면 `push`를 통해 *Stack* 에 저장하고 함수 호출이 종료되면 다음 실행할 함수를 `pop`하여 함수를 실행한다. 스레드 별로 저장공간을 따로 생성하여 관리한다.

       ##### PC Register

       현재 수행 중이거나 다음에 실행할 인스트럭션 주소를 저장한다. 연산 수행 중 발생하는 데이터를 레지스터에 저장하였다가 *CPU*가 필요할 때 가져다 쓴다. 스레드 별로 공간을 만들어 관리한다

       ##### Native Method Stack Area

       자바가 접근할 수 없는 영역은 `C`와 같은 *Low Level* 언어로 작성되어 있다. 따라서 *Native* 코드를 실행시키면서 발생하는 데이터를 *Stack* 구조로 저장하기 위한 공간이다. 스레드 별로 생성된다.

8. #### Lambda 식이란

   *Lambda* 는 함수에 대한 이론적 기반을 세우는 수학적 추상화를 뜻하고 이것을 프로그래밍에 녹여서 표현한 것이 *Lambda* 표현식이다. 프로그래밍에서 *Lambda* 에 근간을 두어 설계한 패러다임이 함수형 프로그래밍이다. 함수형 프로그래밍은 함수의 입력만을 의존하여 출력을 만드는 프로그래밍 패러다임이다. 함수 개념에 근간을 두어 설계하였기에 다음과 같은 특징을 가진다.

   1. 함수를 객체로 사용함으로써 값으로 할당하거나 파라미터로 전달이 가능하다. (고계함수)
   2. 함수를 불변상태로 규정하여 부작용을 최소화하고 멀티 스레드 환경에서 동기성 문제에 안전하다. (순수함수)
   3. 코드를 간결하게 하여 가독성을 높임으로써 로직에 집중시킨다. (익명함수)

   *Java 8* 이전에는 함수에 대한 특별한 개념이 없었고 지원하는 기능도 없었다. 하지만 *Java 8* 에서부터 람다식과 함수형 인터페이스라는 개념을 도입하여 인터페이스 안에 단 하나의 함수를 선언하여 이것을 객체처럼 사용하고 람다식으로 표현이 가능하도록 지원하였다. 또한 단 하나의 함수만 들어가는 것을 보장하기 위해 `@FunctionalInterface` 라고 선언함으로써 컴파일 타임에 에러를 잡을 수 있게 하였다.

   

   

   ## MVC, MVP, MVVM

   *MVC* 는 *Model* 과 *View*, *Controller* 구조를 가지는 디자인 패턴입니다. *Model* 에서 데이터와 상태, 비즈니스 로직을 구현하며 *View* 와 *Controller* 에 종속되지 않고 여러 곳에서 재사용 될 수 있습니다. *View* 는 화면을 구현하는 컴포넌트입니다. *Model* 에 대한 이해없이 오로지 사용자의 인터렉션을 받아 반응합니다. *View* 와 *Model* 은 최대한 종속되지 않고 독립적이게 구현해야 합니다. *Controller* 는 *View* 와 *Model* 을 연결하는 역할을 합니다. *View* 에서 사용자와의 인터렉션이 발생하면 컨트롤러가 이것을 인지하고 모델을 갱신하는 역할을 합니다. 안드로이드에서 *Controller* 는 주로 액티비티에 해당하고 *View* 는 *xml* 파일이 되며 *Model* 은 데이터 클래스 등이 되겠습니다. 원래 MVC 는 *View* 와 *Model* 을 완전히 분리시키고 *Model* 이 어디에도 종속되지 않지만 안드로이드에서 *View* 와 *Controller* 가 액티비티에 같이 구성되어 있어 사실상 하나의 모습을 보입니다. 따라서 *View* 와 *Model* 이 의존적이게 되어 테스트가 어렵고 액티비티 안에 대부분의 처리가 구현되어 스파게티 코드가 될 수 있습니다.

   *MVP* 는 *MVC* 의 문제점을 보완하고자 나온 디자인 패턴입니다. *MVP* 에서는 액티비티를 *View* 의 일부로 간주하여 액티비티 안에 대부분의 처리가 구현되는 것은 극복하였습니다. 액티비티가 *View* 인터페이스를 구현되어 있기에 가상 뷰를 만들어 *Presenter* 와 연결시키면 유닛 테스트가 가능합니다. *Presenter* 는 *MVC* 의 *Controller* 와 역할이 거의 같지만 *View* 와 연결되어 있지 않고 그저 인터페이스라는 차이가 있습니다. *View* 와 *Model* 을 완전히 분리시켜줌으로써 서로의 독립성을 보장한다는 점이 장점입니다. 하지만 *Presenter* 도 시간이 지남에 따라 비즈니스 로직이 모이는 경향을 보입니다. 따라서 문제가 발생하기 쉽고, 분리하기도 어려워 유지보수가 어려워진다는 단점이 있습니다.

   *MVVM* 은 `DataBinding` 을 이용함으로써 모듈화를 쉽게하고 뷰와 모델을 연결하는 코드를 줄일 수 있는 장점을 가진 디자인 패턴입니다. *View* 가 ViewModel 에 의해 바인딩되어 ViewModel 의 값이 변경되면 *View* 가 갱신됩니다. *ViewModel* 은 *Model* 을 *Wrapping* 하는 구조이며 동시에 *View* 가 *Model* 에 이벤트를 전달할 수 있는 훅 기능을 합니다. *Command Pattern* 과 *Data Binding* 을 사용하여 *View* 와 *ViewModel* 의 의존성을 완전히 제거한다는 장점이 있습니다. *MVVM* 패턴 또한 시간이 지남에 따라 관계 없는 로직이 늘어나 *xml* 에 코드가 증가하는 문제가 발생합니다. 이것은 유지보수를 힘들게 하기 때문에 뷰 바인딩 표현식에 값을 계산하지 않고 *ViewModel* 에 직접 값을 가져와 처리해야합니다.

9. 쿠키와 세션

   - HTTP 프로토콜 특징
     - 비연결지향(Connectionless)
       - 클라이언트가 request를 서버에 보내고, 서버에 클라이어느에 요청에 맞는 response를 보내면 연결을 바로 끊는다.
     - 상태유지안함(Stateless)
       - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태정보를 유지하지 않는다.
   - 쿠키와 세션의 필요성
     - HTTP 프로토콜은 위와 같은특징으로 모든 요청 간 의존관계가 없다.
     - 즉 현재 접속한 사용자가 이전에 접속한 사용자인지 알수 없다.
     - 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는것이 큰 장점이지만 통신을 요청할 때마다 인증을 해야한다는 단점이 있다.
     - 이전 요청과 현재요청이 같은지 판별하기 위해 상태를 유지해야한다.
     - HTTP 프로토콜에서 상태를 유지하기 위한 기술이 쿠키와세션이다.
   - 쿠키(Cookie) 란? 
     - 개념
       - 클라이언트 로컬에 저장되는 키와값이 들이었는 파일
       - 이름,값,유효시간,경로 등을 포함
       - 클라이언트의 상태정보를 브라우저에 저장하여 참조
     - 구성요소
       - 이름
       - 값
       - 만료시간
       - 도메인이름
       - 쿠키를 전ㄴ송할 경로
       - 보안 연결 여부
       - Httponly 여부
   - 세션(Session)이란?
     - 개념
       - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
       - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.
     - 웹브라우저가 서버에 요청
     - 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
     - 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송
       쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장

   키와 세션의 차이점

   - 저장 위치
     - 쿠키 : 클라이언트
     - 세션 : 서버
   - 보안
     - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
     - 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
   - 라이프사이클
     - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
     - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
   - 속도
     - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
     - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.

10. REST API 설계 **기본 규칙**

    a. URI는 정보의 자원을 표현해야 한다.

    - resource는 동사보다는 명사를 사용한다.
    - resource는 영어 소문자 복수형을 사용하여 표현한다.
    - Ex) `GET /Member/1` -> `GET /members/1`

    b. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.

    - URI에 HTTP Method가 들어가면 안된다.
    - Ex) `GET /members/delete/1` -> `DELETE /members/1`
    - URI에 행위에 대한 동사 표현이 들어가면 안된다.
    - Ex) `GET /members/show/1` -> `GET /members/1`
    - Ex) `GET /members/insert/2` -> `POST /members/2`

    c. 슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.

    - Ex) `http://restapi.example.com/houses/apartments`

    d. URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.

    - URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
    - REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.

    e. 하이픈(- )은 URI 가독성을 높이는데 사용

    - 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.

    f. 밑줄(_ )은 URI에 사용하지 않는다.

    - 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.

    g. URI 경로에는 소문자가 적합하다.

    - URI 경로에 대문자 사용은 피하도록 한다.
    - RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문

    h. 파일확장자는 URI에 포함하지 않는다.

    - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
    - Accept header를 사용한다.
    - Ex) `http://restapi.example.com/members/soccer/345/photo.jpg (X)`
    - Ex) `GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)`

## Android

1. Android Manifest란

   - 모든 안드로이드 어플리케이션은 반드시 이것을 가지고 있어어 한다.
   - Manifest는 어플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 전달한다.

   기술되는 내용

   - 자바 패키지명 정의
   - 어플리케이션을 구성하는 컴포넌트들을 기술
   - 어플리케이션을 구성하는 컴포넌트들에 대한 해당 클래스명을 정의하고 컴포넌트가 처리할 수 있는 기능이 무엇인지 intent-filter를 정의
   - 안드로이드 애플리케이션이 안드로이드 플랫폼의 제한된 API에 접근하거나 다른 애플리케이션의 제한된 컴포넌트를 사용하기 위해서 필요한 권한을 설정한다.
     – 안드로이드 애플리케이션은 자신의 컴포넌트를 쉽게 사용할 수 없도록 권한을 설정할 수 있다.

2. 이미지 캐시(메모리 캐시,디스크 캐시)

   - 안드로이드 장비가 하나의 앱에 허용되는 메모리는 보통 16MB다. 그 이상 메모리를 가진 어플리케이션도 많지만 그래도 화면에 많은 이미지를 로딩하기에는 이미지가 차지하는 메모리는 크다. 그리고 실제로 이미지 원본은 대부분이 원하는 사이즈보다 크고, 요즘은 해상도가 높아서 용량도 크다. 이러한 문제점때문에 이미지를 로드할 때 주의해야하는 점이 메모리 관리다. 이부분을 간과한다면 java.lang.OutofMemoryError 메세지를 받게 된다

   - **[메모리 캐시 사용]**

     LruCache는 LinkedHashMap을 사용한다.

   - **[디스크 캐시 사용]**

     일반적으로 메모리 캐시와 디스크 캐시의 차이는 메모리 캐시는 처리 속도가 빠르지만 저장 공간이 작고, 디스크 캐시는저장 공간은 상대적으로 크지만 파일 입출력으로 인한 처리 속도가 느리다. 



# Android

- 안드로이드 매니페스트 설명
- xml, view가 그려지는 과정 -> 대답 못함, measure 메소드로 사이즈를 구해서 그린다. 밖에 대답 못했음
  - 지금 생각해보니 `커스텀 뷰를 만들어봤나`를 확인하는 질문인 것 같다.
- constraint layout 설명
- margin start와 left 비교
- 스타일(res -> values -> styles.xml)을 사용해봤나? 언제 사용해야 하나?
- MVVM ViewModel과 AAC ViewModel 차이점
- Room과 SharedPreferences 비교
- 안드로이드 4대 컴포넌트 설명(액티비티, 서비스, 컨텐츠 제공자, 브로드캐스트 수신기)
- DiffUtil(List Adapter) 어떻게 작동하나?
- 액티비티와 프래그먼트 설명
- 액티비티A 실행 - 액티비티B 실행 - 액티비티B 종료, 상황에서 생명주기 설명
- 액티비티 백 스택 설명
- 리스트뷰와 리사이클러뷰 비교
- 리사이클러뷰의 어댑터가 무엇인가? 무슨 역할을 하나?
- 이미지를 가져 올 때 캐시는 어떻게 하나? -> glide의 기본 캐시 기능을 사용했다.

### 개발 일반, 언어, Rx

- 빌드, 컴파일 설명
- 컴파일 타임, 런 타임 설명 -> 대답 못함, 컴파일 되는 중, 실행 되는 중 밖에 모르겠다.

런타임(Runtime)과 컴파일타임(Compiletime)은 소프트웨어 프로그램개발의 서로 다른 두 계층의 차이를 설명하기 위한 용어이다. 프로그램을 생성하기 위해 개발자는 첫째로 소스코드를 작성하고 컴파일이라는 과정을 통해 기계어코드로 변환 되어 실행 가능한 프로그램이 되며, 이러한 편집 과정을 컴파일타임(Compiletime) 이라고 부른다.

컴파일과정을 마친 프로그램은 사용자에 의해 실행되어 지며, 이러한 응용프로그램이 동작되어지는 때를 런타임(Runtime)이라고 부른다.

"런타임"과 "컴파일 타임"이라는 용어는 종종 서로다른 두 가지 타입의 에러를 나타내기 위해 사용되어지곤 하는데, 컴파일 타임 에러는 프로그램이 성공적으로 컴파일링되는 것을 방해하는 신택스에러(Syntax error)나 파일참조 오류와 같은 문제를 말하며, 이런 경우 컴파일러는 컴파일 타임 에러를 발생시키고 일반적으로 문제를 일으킨 소스코드 라인을 지시해준다.

만약, 어떤 소스코드가 이미 실행가능한 프로그램으로 컴파일 되었다 할지라도 이것은 여전히 프로그램의 실행중에 버그를 일으킬 수 있다. 예를 들자면, 예상치 못한 오류 또는 충돌로 동작하지 않을 수 있는데 이렇게 프로그램이 실행중에 발생하는 형태의 오류를 런타임오류 라고 한다.

https://spaghetti-code.tistory.com/35

## 컴파일타임 오류의 유형

- 신택스 오류
- 타입체크 오류

## 런타임 오류의 유형

- 0나누기 오류
- 널(Null)참조 오류
- 메모리 부족 오류



- java 다형성
- java interface와 abstract class 차이
- kotlin data class, 프로퍼티 설명
- 캐시를 FIFO구조로 구현했는데 왜 링크드 리스트를 사용했나?, 링크드 리스트/어레이 리스트/어레이 비교
- 해쉬맵 설명
- 동시성, 비동기 설명
- 클래스, 인스턴스, 오브젝트 설명
- Rx를 쓰면 좋은 점
- Rx가 왜 나왔나?
- Rx Schedulers의 io(), computation() 설명
- 라이브러리와 프레임워크 차이

### 아키텍처, 디자인 패턴

- ㅋClean Architecture
- 레포지터리 인터페이스가 도메인 레이어에 있는 이유
- 비즈니스 로직이 뭔가?
- MVP Presenter와 MVVM ViewModel의 차이, ViewModel의 개념
- repository 패턴 좋은 점
- 싱글톤 패턴, 옵저버 패턴
- 싱글 액티비티 어플리케이션 구조로 한 이유





명시적 인텐트 암시적 인텐트 이해

URL vs URI

## URL ( Uniform Resource Locator)

- 자원

- 예전에는 URL이 가르키는게 파일 소스

- 요즘은 Rewrite등의 아파치,톰켓등의 핸들러 때문에 자원이라고 부름

- 웹사이트 주소가 요청하는 파일이라기 보다는, 구분자로 보는 것

- 웹 상에 서비스를 제공하는 각 서버들에 있는 파일의 위치를 표시하기 위한 것
  \- http://blong.com/work/test.pdf 는 blog.com서버에서 work폴더안의 test.pdf를 요청

  

  ## URI ( Uniform Resource Identifier)

  - 통합 자원 식별자

  - 인터넷에 있는 자원을 나타내는 유일한 주소이다.

  - URI의 존재는 인터넷에서 요구되는 기본조건으로서, 인터넷 프로토콜에 항상 붙어다님
    \- ex) [http://www.naver.com](http://www.naver.com/) (http프로토콜임을 명시하고 있음)

  - URI의 하위개념에 URL,URN이 포함되어 있다.

  - URI의 보편적인 형태가 URL인데, URI의 부분집합으로 볼 수 있다.

    \- 자원에 접근하기 위해 사용되는 절차

    - 어떤 자원을 가지고 있는 특정한 컴퓨터
    - 컴퓨터 상의 유니크한 자원의 이름(파일명)

  - http://test.com/test.pdf?docid=111

     

    이라는 주소는 URI이지만 URL은 아니다.

    \-

     

    http://test.com/test.pdf

     

    까지만 URL임(주소의 위치)

    - docid=111이라는 쿼리스트링의 값에 따라 결과가 달라지게됨, 따라서 식별자 역할을 하고 있음

  - http://test.com/test.pdf?docid=111 ,[http:/](http://test.com/test.pdf?docid=112는)

## String Intern

`String` 객체는 불변 객체이기 때문에 동일한 객체가 공유될 수 있는 특징을 가지고 있습니다.

이 특징을 잘 활용하기 위해서는 동일한 문자열을 가지는 `String` 객체가 단 하나만 존재하도록 유지할 필요가 있습니다.

`intern` 메서드가 이러한 목표를 달성하기 위해 제공되는 메서드입니다.

JVM 내부에서 초기에는 비어있는, 문자열 객체를 관리하는 풀(pool)을 생성합니다.

이후, `String` 객체의 `intern` 메서드가 호출되면 이 풀에 해당 문자열과 같은(`String.equals()` 반환값이 `true`인) `String` 객체가 존재하는 경우 해당 객체를 반환하고, 존재하지 않는 경우 해당 객체를 풀에 추가하고 해당 객체를 반환하게 됩니다.



## 인터넷 사이트는 자신의 정보와 공개키를 인증기관에 제출한다.

인증기관은 제출된 데이터 검증절차를 거쳐 개인키로 사이트에서 제출한 정보를 암호화한다. ==> **인증서 발급**

인증기관은 웹 브라우저에게 자신의 공개키를 제공한다.



https://devdy.tistory.com/14

사용자가 사이트에 접속하면 자신의 인증서를 웹 브라우저에게 보낸다.

웹브라우저는 미리 받았던 인증기관의 공개키로 인증서를 해독하여 검증한다. 그러면 사이트의 정보와 사이트의 공개키를 알 수 있게 된다.

이렇게 얻은 사이트 공개키로 대칭키를 암호화해서 다시 사이트에 보낸다.

사이트는 개인키로 암호문을 해독해 대칭키를 얻게 되고, 이제 대칭키로 데이터를 주고받을 수 있게 된다.



https://devdy.tistory.com/14



트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

### 트랜잭션의 특성

*트랜잭션은 어떠한 특성을 만족해야할까?* Transaction 은 다음의 ACID 라는 4 가지 특성을 만족해야 한다.

#### 원자성(Atomicity)

만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

#### 일관성(Consistency)

트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

#### 고립성(Isolation)

각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

#### 지속성(Durability)

트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.



## NEW 생성시 생기는 일

new는 클래스 타입의 **인스턴스(객체)를 생성해주는 역할****메모리(Heap 영역)에 데이터를 저장할 공간을**  그 공간의 참조값(reference/해시코드)을하여 주고([메모리](http://blog.naver.com/heartflow89/220954420688), [객체 및 인스턴스](http://blog.naver.com/heartflow89/220952631257) 포스팅 참고) 이어서 하게 된다. 인스턴스를 핸들하기 위해서는 new 연산자를 통해 참조값을 저장한 객체로만 접근이 가능하다. 정리하면 아래와 같다.**[출처]** [[JAVA/자바\] new 연산자](http://blog.naver.com/heartflow89/220955262405)|**작성자** [JOKER](http://blog.naver.com/heartflow89)을 담당한다. 여기에 조금 더 설명을 붙이면 new 연산자를 통해 할당받고 value  객체에게 반환생성자를 호출



## Context 란

어플리케이션의 정보에 접근하기 위한 인터페이스입니다. `Context` 를 사용하면 `getPackageName()` , `getResource` 등과 같이 어플리케이션에 대해 시스템이 관리하는 정보에 접근할 수 있으며 `startActivity()` , `bindService` 등과 같이 안드로이드가 제공하는 시스템 서비스를 사용할때도 사용됩니다. 보통 다른 프로그램에서 시스템 레벨에서 제공하는 전역 정보에 접근하기 위해 `System` 정적 클래스에 접근하는 것과 비슷한 맥락입니다. 안드로이드에서는 어플리케이션 관리를 시스템에서 하는 것이 아니라 별도의 `ActivityManagerService` 라는 또다른 어플리케이션이 관리하고 있기 때문에 어플리케이션과 연관된 시스템 레벨의 함수를 호출하려면 `ActivityManagerService` 를 통해야 합니다. 따라서 `ActivityManagerService` 에게 자신이 어떤 어플리케이션인지 알리고 시스템 레벨의 함수에 접근하기 위해서 `Context` 객체가 필요한 것입니다.

안녕하세요 학부시절 공모전에서 안드로이드 앱 개발을 맡은 것을 시작으로 좀더 많은 사람들에게 쓰이는 어플리케이션을 만들고 싶어 대외활동이나 공모전에서 안드로이드 개발을 해왔었고 최근에는 작은 창업회사에 합류하여 머케인 메이트라는 전동 킥보드 공유 어플리케이션을 개발해 본적이 있습니다. 안드로이드 개발자로서 고이지 않고 계속 학습해야 한다고 생각해서 medium에서 안드로이드 섹션 이나 안드로이드 개발 소식 을 구독해서 정보를 얻고 있습니다.



# lateinit

초기화 지연 프로퍼티(Late-initialized property)라고 하며 프로퍼티의 초기화를 나중에 하기 위해 사용하는 키워드다. 프로퍼티 선언에 사용되며 항상 사용 가능한 것은 아니다. 사용하기에 몇 가지 제약사항이 있다.

- var(mutable) 프로퍼티만 사용 가능
- non-null 프로퍼티만 사용 가능
- 커스텀 getter/setter가 없는 프로퍼티만 사용 가능
- primitive type 프로퍼티는 사용 불가능
- 클래스 생성자에서 사용 불가능
- 로컬 변수로 사용 불가능

# Lazy

`lazy`도 `lateinit`과 마찬가지로 초기화를 지연시킬 때 사용하며 `lateinit`은 Modifier 지만 `lazy`는 람다를 파라미터로 받고 `Lazy<T>` 인스턴스를 반환하는 함수다. `lazy`도 사용에 제약사항이 있는데 `lateinit`과 차이점이 있다.

- val(immutable) 프로퍼티만 사용 가능
- primitive type에도 사용 가능
- 커스텀 getter/setter가 없는 프로퍼티만 사용 가능
- Non-null, Nullable 둘 다 사용 가능
- 클래스 생성자에서 사용 불가능
- 로컬 변수에서 사용 가능







